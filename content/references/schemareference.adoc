[[cdSchemaReference]]
=== Definition Reference Guide

In this section we will break down all the available Definition options by section and explain their usages.

The general structure of each section will start with guidance on the minimally required information for that type of Deployment, followed by guidance on the various options.

For an introduction to the basics of Definition creation and the most common options, please see the xref:cdDeployments[Deployments] Section.

==== Profile

The default Cloudera-Deploy user profile is instantiated by the quickstart.sh script from a template file https://github.com/cloudera-labs/cloudera-deploy/blob/main/profile.yml[profile.yml] in the repository, and written to `~/.config/cloudera-deploy/profiles/default`

The values in the profile are among the most common to be set for a Deployment, as such the User has several options where they can be set:

* Values in the `default` profile will be picked up at the lowest priority
* if the user provides the path to an alternative `profile.yml` via the extra-vars option `abs_profile`, that will be used instead of the default profile
* The User may set the values from the Profile in definition.yml, which will override the previous stated options
* The User may pass in the values as extra-vars at runtime, which overrides almost anything else.

IMPORTANT: Many Profile values use bash expansion of the user's home directory (`~/`)to refer to files, this allows the same path to work on your local machine AND in the Runner. Using absolute paths (`/home/user`) *in the Profile* is strongly advised against, but should be fine elsewhere in the Framework.

===== Default Password
[source,yaml]
admin_password: Mysecretpword1!

IMPORTANT: You must provide an `admin_password` to the Framework in some manner, it is the only mandatory value which we do not set a default for.

This password will be propagated to your CDP Public Workload User, the admin user in CDP Base, and anywhere else a security value may be required such as in a database required by the Definition you supply.

We recommend you set individual passwords for separate services in *serious deployments* using the overrides available for each of these values in the Definition. For Demo and Development a common password is a lot easier.

.Password Complexity
Recommended 12-16 chars, 1 Cap, 1 num, 1 special (avoid '#', '?' and '/' for some subsystems).

This satisfies password requirements for *most* subsystems.

What we mean by this is that the Framework automates many, many subsystems for you depending on what you put in the Definition, and each of those subsystems has different security standards. We strive to balance having security out-of-the-box with an easy to set default value.

===== Namespace
[source,yaml]
name_prefix: cldr

Where names are procedurally generated by the Framework, rather than explicitly provided by the user, this will be prefixed. Sometimes it will be joined with other sources of uniqueness, such as the first two characters of the cloud provider, to generate a unique name for a given subsystem.

All deployment names should be prefixed to allow differentiation and accurate discovery or filtering. You are recommended to combine this with unique default Tags when there are a lot of Deployments sharing some Tenant to avoid clashes.

NOTE: Many subsystems require that deployments within a given Tenant have a unique name, as such you should avoid using the default name prefix `cldr` if multiple people may be using this automation Framework in your Deployments.

Ideally it should not exceed 6 chars, and must start with a letter. your personal Initials are an excellent option in most cases.

WARNING: Do not use punctuation in your `name_prefix`, particularly '-' and '_' can cause extremely weird behavior in some subsystems, particularly security subsystems.

WARNING: If you are deploying to Azure, we strongly recommend it be <= 4 chars, as Azure has quite short field character count limits in some cases, particularly storage.

It will default to the name_prefix `cldr` as set in https://github.com/cloudera-labs/cloudera-deploy/blob/main/roles/cloudera_deploy/defaults/main.yml[roles/cloudera_deploy/defaults] if not provided by the User.

===== Default Tags

These tags are applied by default to all deployed infrastructure, particularly chargeable infrastructure on cloud providers.

You can also set specific Tags on specific deployments, such as a Datahub, in their sections of the Definition.

Some subsystems require certain tags to self-identify different functions, this is particularly common with certain cloud Kubernetes implementations. These will be automatically applied for you where appropriate.

You should use tags to identify your services to make it easy to track and remove them when no longer needed.

[source,yaml]
tags:
  owner: dchaffelson@cloudera.com
  enddate: "01312022"

IMPORTANT: The two-space indent of the tag `key: value` pairs is critical for correct YAML structure

NOTE: For backwards compatibility reasons, we give the example date above in American or 'Freedom' format of MMDDYYYY. We recommend most people use ISO8601 or YYYYMMDD format.

===== Cloud Infrastructure

.Cloud Provider
Specifies the Cloud Infrastructure provider, CDP presently supports GCP, AWS and Azure

[source,yaml]
infra_type: aws  # gcp, azure

NOTE: Only necessary when using Public Cloud Infrastructure and when you do not specify an Ansible Inventory

.Cloud Region
Specify the default region you prefer for your infrastructure provider

It must be valid for the selected infra_type

[source,yaml]
infra_region: us-east-1

IMPORTANT: Generally it is not a problem if the region you set in Definition (or these defaults) differs from the region you have set in the CLI Config. The exception is where you wish to combine other tools with this Framework and they start looking in a different region. Be mindful of mixed configurations.

The automation service attempts to validate that the requested build will work in the given region, so some may be rejected as not all regions provide all cloud services.

NOTE: You are advised to build a reference deployment, including all services you intend to use, before investing into data and application development in a particular Cloud provider or region. You can immediately remove it once this validation is complete.

https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html[Listing] of AWS regions.

https://azuretracks.com/2021/04/current-azure-region-names-reference[Listing] of Azure regions (Note: not microsoft.com).

Or you can run this in the runner:

[source,bash]
az account list-locations --query '[*].name'

https://cloud.google.com/compute/docs/regions-zones[Listing] of GCP regions.

===== Cloud Credentials

Path to Google Cloud Credentials file, if using Google Cloud

Should be in your local profile

WARNING: We recommend they should not be located anywhere near a version controlled directory like git to avoid accidental inclusion!

If using Azure or AWS the credentials will be automatically collected from your local user profile; these credentials are required because Deployments require a GCP Service Account which is handled differently.

[source,yaml]
gcloud_credential_file: '~/.config/gcloud/mycreds.json'

===== SSH

NOTE: Your SSH keys should be in your local profile (typically `~/.ssh`), or the Definition Path, or some other persistent directory available to the Runner. You are advised to be careful of not inadvertently committing your private SSH keys to version control.

NOTE: If you have set the necessary SSH Information into your Ansible Inventory for deploying CDP Base, you can leave these fields commented out of your profile. They are only really necessary for Public Cloud Deployments.

====== Public Key File

A Public Key file is required if using Azure or GCP as Cloud Infrastructure, or deploying Private Cloud

If not supplied, one will be generated using the supplied `name_prefix`, along with a matching Private Key file, and ignoring the `private_key_file` setting below. The default location is the usual ssh path in the User's Home Directory `~/.ssh`

[source,yaml]
public_key_file: '~/.ssh/cldr.pub'

====== Private key file
Required if deploying Dynamic Inventory to set the Ansible Connection Parameters.

NOTE: Must be set if public_key_file is set as Ansible validates that your keys match as a convenience

[source,yaml]
private_key_file: '~/.ssh/cldr.pem'

====== Key Name

Required for AWS Cloud Infrastructure

Defaults to the Namespace if not set

Must be set if public_key_file is set, even if not using AWS.

[source,yaml]
public_key_id: cldr

===== Cloudera License

Path to your Cloudera License file, if you want to supply one.

Required if deploying a CDP Cluster for Private Cloud in a mode other than Trial, or where files are required to be downloaded from behind authentication on archive.cloudera.com

Should be in your local profile using bash expansion, or the definition directory.

[source,yaml]
license_file: "~/.cdp/my_cloudera_license.txt

NOTE: Putting the license file in `~/.cdp/` is a convenient convention, but not required.

===== Full Profile YAML

[source,yaml]
admin_password: Mysecretpword1!
name_prefix: cldr
tags:
  owner: dchaffelson@cloudera.com
  enddate: "01312022"
infra_type: aws
infra_region: us-east-1
gcloud_credential_file: '~/.config/gcloud/mycreds.json'
public_key_file: '~/.ssh/cldr.pub'
private_key_file: '~/.ssh/cldr.pem'
public_key_id: cldr
license_file: "~/.cdp/my_cloudera_license.txt"

==== Globals

Globals is a structure to allow particular variables to be propagated across the entire Framework in a simple dictionary, and they are usually set by the top level playbook and then inherited by the Collections.

Globals are usually taken from some default or User set value, as such you are advised to not set the `globals` dictionary directly, as you may squash other variables the Framework expects to be there. If you want to change something you have found in `globals` during debugging, look to where it is set upstream in the Playbook or other locations.

Generally only add new values to globals when developing new features if they are needed in multiple Collections, such as `cloudera.exe` and `cloudera.cluster`.

===== General
The Globals in this section are explained elsewhere, as most come from the User Profile in Cloudera-Deploy, or are derived from its initialization process.

[source,yaml]
globals:
  admin_password: MySuperSecret1!
  artifacts:
    create_deployment_details: yes
    directory: ~/.config/cloudera-deploy/artifacts
  cloudera_license_file: ~/.cdp/my_cloudera_license.txt
  create_utility_service: yes
  dynamic_inventory:
    vm:
      count: 6
      os: centos8
  gcloud_credential_file: ~/.config/gcp/credentials.json
  infra_type: aws
  name_prefix: cldr
  namespace_cdp: cldr-aw
  region: eu-west-1
  tags:
    mykey: myvalue
  utility_bucket_name: cldr-0123456789-uk-west-1

===== Object Storage Name
[source,yaml]
globals:
  storage:
    name: us-west-1-default

This particular global is to allow the User to set a unique value to be used when constructing the name for a cloud object store, such as an S3 bucket or Azure storage account.

It defaults to the region + aws profile name for AWS, and just the name of the region for the other clouds. When combined with the namespace, this is usually sufficiently unique for most users.

This odd construction is necessary because, unlike most other cloud resources, these names much be globally unique to all accounts. This is not always the case, but as it usually is we opt for a solution which is less likely to surprise the user with an unexpected error.

===== SSH

Unfortunately the different cloud providers, and OS types that you may use, tend to have slightly different requirements when it comes to remote access via SSH. As such, you may observe there are several options for providing your SSH credentials to the Framework.

In most cases you are advised to supply the path to your `public_key_file` and `private_key_file` in your profile.

If you are using AWS, you should set the `public_key_id` to match.

You may supply the `public_key_text` directly for some Azure use cases, but we will look it up from the file if you supply `public_key_file` instead, and this latter option is preferred security practice.

[source,yaml]
globals:
  ssh:
    key_path: ~/.ssh
    private_key_file: ~/.ssh/mykey.pem
    public_key_file: ~/.ssh/mykey.pub
    public_key_id: mykey
    public_key_text:

===== Labels

The global labels are the short strings used as identifiers when constructing larger labels for uniqueness. It allows us to procedurally generate the different names from standard pieces.

They are deliberately short in some cases due to restricted character counts on some fields.

[source,yaml]
globals:
  labels:
    admin: admin
    app: app
    cml: cml
    cde: cde
    credential: cred
    cross_account: xaccount
    data: data
    datalake: dl
    datalake_admin: dladmin
    default: default
    env: env
    group: group
    idbroker: idbroker
    identity: identity
    internet_gateway: igw
    knox: know
    logs: logs
    policy: policy
    private: pvt
    public: pub
    ranger_audit: audit
    role: role
    service_network: svcnet
    storage: storage
    subnet: sbnt
    table: table
    user: user
    vpc: vpc
    vpce: vpce

==== Infrastructure

===== AWS
[source,yaml]
infra:
  aws:
    profile:
    region:
    arn_partition:
    vpc:
      az_count:
      internet_gateway:
        name:
        suffix:
      labels:
        public_route_table:
        private_route_table:
        public_route_table_suffix:
        private_route_table_suffix:
      existing:
        vpc_id:
        public_subnet_ids:
        private_subnet_ids:
    role:
      tags:
    policy:
      tags:
    storage:
      tags:
    private_endpoints:

===== Azure
[source,yaml]
infra:
  azure:
    metagroup:
      name:
      suffix:
    netapp:
      account:
        name:
        suffix:
      pool:
        name:
        size:
        suffix:
        type:
      suffix:
      volume:
        name:
        size:
        suffix:
        type:
    region:
    sp_login_from_env:
    storage:
      class:
      name:
      type:

===== Dynamic Inventory

[source,yaml]
infra:
  dynamic_inventory:
    storage:
      delete:
      size:
      type:
    tag:
    tag_key:
    tag_value:
    vm:
      suffix:
      type:

===== GCP

[source,yaml]
infra:
  gcp:
    project:
    region:
    storage:
      path:
        data:
        logs:

===== Security Groups

[source,yaml]
infra:
  security_group:
    default:
      name:
      suffix:
    knox:
      name:
      suffix:
    vpce:
      name:
      suffix:

===== Storage

[source,yaml]
infra:
  storage:
    name:
    path:
      data:
      de:
      logs:
      ml:
      ranger_audit:

===== Teardown

[source,yaml]
infra:
  teardown:
    delete_data:
    delete_mirror:
    delete_network:
    delete_ssh_key:

===== VPC Networking

[source,yaml]
infra:
  vpc:
    cidr:
    extra_cidr:
    extra_ports:
    name:
    private_subnets:
    private_subnets_suffix:
    public_subnets:
    public_subnets_suffix:
    service_network:
      name:
      subnet:
    user_cidr:
    user_ports:
    tunneled_cidr:

==== Environment

The Environment definition is one of the largest, because the Framework takes the position that it will only work with one Environment per run for CDP Public. This gives us the convenience of using it as encapsulating object for all configuration at the Platform level.

We'll break the `env` key down into sections around the direct keys and then the complex sub-keys, and then provide the full schema at the end of this section as usual.

===== Top Level Environment Keys

These keys are also at the top level under `env`, but do not have complex substructures and therefore do not need breaking out into a separate explanation

[source,yaml]
env:
  name: cldr-aw-env
  suffix: env
  workload_analytics: yes  # no
  tunnel: yes  # no
  public_endpoint_access: yes  # no

.Name
The name may be supplied here, or it will be procedurally generated by concatenating the namespace, cloud provider, and suffix. We include the cloud provider in the generated name as the user may wish to make a group of environments within a namespace but across multiple clouds, and the names must be distinct.

IMPORTANT: The first eight characters of the name of the Environment must be unique within the CDP Tenant, as they are used in generating various DNS entries for some cloud subsystems which you probably do not want to clash.

.Suffix
The suffix used when generating the name procedurally, if the name is not directly provided.

Note that the suffix can be set here within the Environment definition, or at the globals level if you are composing your configs.

.Workload Analytics

This simple true | false value enables workload analytics for this particular environment.

It defaults to false.

===== L0, L1, and L2 network architectures
One of the main consequential decisions when deploying a CDP Public Environment is the Cloud Networking Architecture you wish to deploy. While this has more complex implications in terms of the Network topology created, we abstract the typical cases into top level flags here.

We generally refer to network setups for CDP Public as falling into three categories.

If all nodes have public IPs and internet access, we call this L0 or Public - set tunnel & endpoints to false
If gateway nodes have public IPs, but other nodes do not, we call this L1 or semi-public - set tunnel & endpoints to true
If no nodes have public IPs, we call this L2 or private - set tunnel to true and endpoints to false

Note that L0 and L1 will work out of the box as the Framework will put the IP of the Ansible Controller on the network security allow-list by default. This is a practical consideration because the Controller _usually_ needs to connect to hosts to do more configuration work, and the User also _usually_ wants to access those machines from their workstation which is _usually_ running the Controller.

For an L2 configuration, the User will need to have some other arrangements to access to the private IPs within the deployed network. Perhaps a jumpbox, VPN, VPC Peering, or one of many such possibilities. These deployments are typical of Production cloud networking in enterprise customers and setup of them is outside the scope of this Framework.

.Tunnel
Setting tunnel option to true enables CCM gateway which removes the need for the environment hosts to have a public IP address.

The default is false.

.Public Endpoint Access
Setting public_endpoint_access to true enables public workload endpoint access gateway which lets users access workload from the internet.

The default is false.

Needed when tunneling is enabled, but you don't have the direct connectivity with the VPC via a VPN or similar.

===== Environment AWS sub-structure

As the actual definition of Infrastructure to be deployed on AWS lives under the `infra` tag, this section under `env` is primarily concerned with handling the naming and deployment of the necessary Policies and Roles.

While the Roles and Policies are created on AWS, and therefore you would reasonably think they should be part of the Infrastructure section, we moved them into the Platform section because the selection of Roles and Policies is closely tied to the shape of the CDP Public Environment and Datalake to be created, especially the cross-account access. It's not a perfect demarcation, but we have found this setup to be the least-worst of the available options.

.Policy Naming

Every value in this section has a practical default.

You can override the suffix used in policy name generation with the `suffix` key, or directly set the literal name used for the policy object with the appropriate `name` subkey.

You may set tags to be applied to Policies here.

We plan to support directly supplying the policy documents from local files in the future, presently the Framework uses the official Cloudera policies directly from Cloudera's codebase.

[source,yaml]
env:
  aws:
    policy:
      name:
        bucket_access: cldr-bucket-access-pol
        cross_account: cldr-xaccount-pol
        datalake_admin_s3: cldr-dl-admin-pol
        idbroker: cldr-idbroke-pol
        log: cldr-log-pol
        ranger_audit_s3: cldr-ranger-s3-audit-pol
      suffix: pol
      tags:
        pol_key: pol_val

.Roles

Similar to Policies above, here you can set the `label` used when generating names for Roles. The label simply specifies the short descriptive string for that individual component type, and the 'suffix' is the string appended for this particular class of object.

If you do not set them here in the Environment configuration, they are usually set to one of the global suffix or label defaults. As such, you do not need to set any of these values in most cases.

You can also set the names for the Roles directly.

[source,yaml]
env:
  aws:
    role:
      label:
        cross_account: xaccount
        datalake_admin: dladmin
        idbroker: idbroker
        log: log
        ranger_audit: audit
      name:
        cross_account: cldr-xaccount-rl
        datalake_admin: cldr-dladmin-rl
        idbroker: cldr-idbroker-rl
        log: cldr-log-rl
        ranger_audit:

.Storage

Here you can simply override the default suffix used for naming policies and Roles for storage.

Not to be confused with the naming of buckets or storage accounts in the Infrastructure definition.

[source,yaml]
env:
  aws:
    storage:
      suffix:

===== Environment Azure sub-structure

.Azure Application Name

Explicitly set the name, or just the suffix to use when procedurally generating the name.

[source,yaml]
env:
  azure:
    app:
      name: cldr-xaccount-app
      suffix: app

.Azure Custom Policy for Cross Account Role

The Policy is stored in version control in Cloudera Labs and set to the minimum necessary policies for all CDP Public deployments to function.

You use your own policy document if you wish, but we recommend consultation with Cloudera Support first.

You may also override the suffix used when naming the Policy during creation

[source,yaml]
env:
  azure:
    policy:
      suffix: policy
      url: https://raw.githubusercontent.com/cloudera-labs/snippets/main/policies/azure/cloudbreak_minimal_multiple_rgs_v1.json

.Azure Roles

[source,yaml]
env:
  azure:
    role:
      assignment:
        cross_account:
          contributor:
          role:
        datalake_admin:
          data:
            storageowner:
          logs:
            storageowner:
        idbroker:
          mgdidentop:
          vmcontributor:
        log:
          storagecontr:
        ranger_audit:
          storagecontr:
      label:
        data:
        datalake_admin:
        idbroker:
        identity:
        log:
        ranger_audit:
        xaccount:
      name:
        cross_account:
        datalake_admin:
        idbroker:
        log:
        ranger_audit:
      name_suffix:
        admin:
        assignment:
        contributor:
        operator:
        owner:
        user:
      suffix:

.Azure Storage

[source,yaml]
env:
  azure:
    storage:
      path:
        data:
        logs:
      suffix:

===== Environment GCP sub-structure

[source,yaml]
env:
  gcp:
    bindings:
      cross_account:
      logs:
    role:
      label:
        cross_account:
        datalake_admin:
        idbroker:
        identity:
        log:
        ranger_audit:
      name:
        cross_account:
        datalake_admin:
        idbroker:
        identity:
        log:
        ranger_audit:
      suffix:
    storage:
      path:
        data:
        logs:
      suffix:

===== Environment CDP sub-structure

[source,yaml]
env:
  cdp:
    admin_group:
      name:
      resource_roles:
      roles:
      suffix:
    control_plane:
      cidr:
      ports:
    credential:
      name:
      name_suffix:
      suffix:
    cross_account:
      account_id:
      external_id:
    group_suffix:
    user_group:
      name:
      resource_roles:
      roles:
      suffix:

===== Environment Datalake sub-structure

[source,yaml]
env:
  datalake:
    name:
    suffix:
    user_sync:
    version:
    scale:

===== Environment Teardown sub-structure

[source,yaml]
env:
  teardown:
    delete_admin_group:
    delete_credential:
    delete_cross_account:
    delete_policies:
    delete_roles:
    delete_user_group:

==== Datahubs

When the `datahub` key is included at the top level, you are required to provide an array of `definitions` providing at enough information for the Framework to know which one you want deployed.

Datahub Deployment configurations are prepared in the `Prepare for CDP Datahub clusters` task within the https://github.com/cloudera-labs/cloudera.exe/blob/main/roles/runtime/tasks/initialize_base.yml[cloudera.exe.runtime.initialize_base] Role within the Cloudera.exe Collection.

They are deployed in the `Request CDP Datahub deployments` Task within the `cloudera.exe.runtime.setup_base` Role, and leverage the https://cloudera-labs.github.io/cloudera.cloud/datahub_cluster.html[cloudera.cloud.datahub_clusters] module.

===== Minimum Datahub Definition
The minimal definition to create a Datahub is to provide the name of a predefined Datahub Definition in the `definition` key within the array of definitions under the datahub key, e.g.
[source,yaml]
datahub:
  definitions:
      definition: Streams Messaging Light Duty for AWS

NOTE: A listing of available Datahub Definitions can be found in the CDP UI by navigating to: +
`Management Console > Environments > Your Environment > Cluster Definitions`

You may also use a Jinja Template via the `include` key, there is an example https://github.com/cloudera-labs/cloudera.exe/blob/main/roles/runtime/templates/datahub_streams_messaging_light.j2[here]

You may also specify a CDP Datahub Template (sometimes called a Cluster Blueprint) using the `template` key, which will be paired with the `instance_groups` (either from defaults, or supplied by you) in order to produce a Definition to be deployed.

NOTE: Available Cluster Templates, including Custom Templates, can be found in the CDP UI by navigating to:  +
`Management Console > Shared Resources > Cluster Templates`

So, in summary, a Datahub Definition is a combination of a Template and Instance Groups. You may either use predefined Datahub Definitions from the CDP Control Plane, or pass in various methods of constructing one yourself.

====== Naming your Datahubs

If you do not supply a `name` key in your Datahub Definition, the Framework will attempt to create a name for you.

Datahub names must be unique within a Tenant, so you have several options:

. You are advised to supply your own unique name as the best option
. Or you can set the `suffix` key which will be concatenated with the namespace and cloud provider in order to generate a fairly unique but deterministic name, e.g. the suffix `dhub01` with the namespace `cldr` on AWS would produce `cldr-aw-dhub01`

====== Instance Groups

You may provide a detailed specification of your own instance groups, either on a per-Datahub basis in the `definitions` array, or by supplying a replacement `instance_group_base` key.

In most cases this is not recommended, as they predefined Datahub Definitions have best-practice configurations in place.

Of particular note for `instance_groups` are the look-up tables in https://github.com/cloudera-labs/cloudera.exe/blob/main/roles/runtime/vars/main.yml[cloudera.exe.runtime.vars] which specify defaults for compute and storage used in various cases. You may wish to change the types and sizes of these values to suit your own scale.

NOTE: If you use a pre-defined Datahub Definition using the `definition` key, the instance_groups here are ignored, as the Definition has them baked in. You need to use a `template` or one of the other methods to override the instance_groups.

===== Image Catalog

When constructing a Datahub Template, the appropriate image for deployment is selected from the CDP Control Plane Image Catalog.

The default https://docs.cloudera.com/data-hub/cloud/create-cluster-aws/topics/mc-choose-image-catalog.html[Image Catalog] for CDP is used, but you may supply the name and URL for a custom image catalog if you wish.

Preparing a custom image catalog is outside the scope of the Automation Framework.

===== Full Datahub Definition
This is the full specification with the most common default values included for your convenience.

In most cases you would not supply most of these values in your own Definition, and actually doing so is likely to cause a maintenance burden.

[source,yaml]
datahub:
  definitions:
    - name: streams-messaging-dhub-01
      include: datahub_streams_messaging_light.j2
      template: Streams Messaging Light Duty: Apache Kafka
      definition: Streams Messaging Light Duty for AWS
      suffix: streams-dhub-01
      instance_groups:
        - nodeCount: 1
          instanceGroupName: master
          instanceGroupType: GATEWAY
          instanceType: "{{ run__datahub_compute[run__infra_type].std_gp }}"
          rootVolumeSize: 100
          recoveryMode: MANUAL
          recipeNames:
            - some_recipe_name
          attachedVolumeConfiguration:
          - volumeSize: 100
            volumeCount: 1
            volumeType: "{{ run__datahub_storage[run__infra_type].std }}"
      tags:
        key: value
  compute:
    aws:
      std_gp: 'm5.2xlarge'
      lrg_gp: 'm5.4xlarge'
      std_mem: 'r5.4xlarge'
      dsk_mem: 'r5d.4xlarge'
      std_gpu: "p2.8xlarge"
    azure:
      std_gp: 'Standard_D8_v3'
      lrg_gp: 'Standard_D16_v3'
      std_mem: 'Standard_D16_v3'
      dsk_mem: 'Standard_D8_v3'
      std_gpu: 'Standard_D8_v3'
    gcp:
      std_gp: 'e2-standard-8'
      lrg_gp: 'e2-standard-8'
      std_mem: 'e2-standard-8'
      dsk_mem: 'e2-standard-8'
      std_gpu: 'e2-standard-8'
  image_catalog:
    name: cdp-default
    url: https://cloudbreak-imagecatalog.s3.amazonaws.com/v3-prod-cb-image-catalog.json
  instance_group_base:
    nodeCount: 1
    instanceGroupName: master
    instanceGroupType: GATEWAY
    instanceType: "{{ run__datahub_compute[run__infra_type].std_gp }}"
    rootVolumeSize: 100
    recoveryMode: MANUAL
    recipeNames:
      - some_recipe_name
    attachedVolumeConfiguration:
      - volumeSize: 100
        volumeCount: 1
        volumeType: "{{ run__datahub_storage[run__infra_type].std }}"
  storage:
    aws:
      std: 'standard'
      fast: 'st1'
      eph: 'ephemeral'
    azure:
      std: 'StandardSSD_LRS'
      fast: 'StandardSSD_LRS'
      eph: 'StandardSSD_LRS'
    gcp:
      std: 'pd-standard'
      fast: 'pd-standard'
      eph: 'pd-standard'

==== Data Engineering

[source,yaml]
de:
  definitions:
    - name: cde-01
      instance_type: 'm5.2xlarge'
      minimum_instances: 1
      maximum_instances: 4
      minimum_spot_instances: 0
      maximum_spot_instances: 0
      enable_public_endpoint: yes
      enable_workload_analytics: yes
      initial_instances: 1
      initial_spot_instances: 0
      root_volume_size: 100
      chart_value_overrides:
        - chartName: dex-app
        - overrides: dexapp.api.gangScheduling.enabled:true
      skip_validation: yes
      tags:
        definition-tag: value
      use_ssd: yes
      virtual_clusters:
        - name: cloudera-deployed-vc-1
          cpu_requests: 32
          memory_requests: '128Gi'
          spark_version: 'SPARK2'
          acl_users: '*'
          runtime_spot_component: 'NONE'
          chart_value_overrides:
           - chartName: dex-app
           - overrides: pipelines.enabled:true
  suffix: de-svc
  tags:
    default_tag: value
  force_delete: no
  vc_suffix: de-vc

==== Data Flow

[source,yaml]
df:
  suffix:
  min_k8s_nodes:
  max_k8s_nodes:
  public_loadbalancer:
  loadbalancer_ip_ranges:
  kube_ip_ranges:
  cluster_subnets:
  loadbalancer_subnets:
  teardown:
    persist:
  force_delete:
  terminate_deployments:

==== Data Warehouse

[source,yaml]
dw:
  definitions:
  suffix:

==== Machine Learning

[source,yaml]
ml:
  definitions:
  k8s_request_base:
  suffix:
  tags:
  public_loadbalancer:

==== Operational Database

[source,yaml]
opdb:
  definitions:
  suffix:

==== Data Management

[source,yaml]
data:
  storage:
    # A list of lists of locations (read/[only|write]) defined in a policy and assigned to a Role
    - read_only: bool
      locations: []
      policy:
        name:
        suffix:
        delete: bool
      role:
        datalake_admin: bool
        name:
        suffix:
        delete: bool
  policy:
    suffix:
    aws:
      suffix:
      read_only:
        suffix:
        url:
      read_write:
        suffix:
        url:
  role:
    suffix:
    aws:
      suffix:
  teardown:
      delete_policies:
      delete_roles:
